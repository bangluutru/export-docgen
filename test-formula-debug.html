<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Deep Template Row Dump</title>
    <style>
        body {
            font-family: monospace;
            background: #111;
            color: #eee;
            padding: 20px;
            font-size: 12px;
        }

        .pass {
            color: #4f4;
        }

        .fail {
            color: #f44;
        }

        .info {
            color: #8af;
        }

        .warn {
            color: #fa0;
        }

        .important {
            color: #f0f;
            font-weight: bold;
        }

        h2 {
            color: #aaf;
            margin-top: 20px;
        }

        .data {
            color: #8d8;
        }

        .footer {
            color: #f88;
        }

        .header {
            color: #88f;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="xlsx-reader.js"></script>
    <script src="template-engine.js"></script>
</head>

<body>
    <h1>Deep Template Row Dump — Finding Duplicate Footer Source</h1>
    <div id="output"></div>
    <script>
        const out = document.getElementById('output');
        function log(msg, cls = 'info') { out.innerHTML += `<div class="${cls}">${msg}</div>`; }
        function section(title) { out.innerHTML += `<h2>${title}</h2>`; }

        window.addEventListener('load', async () => {
            try {
                const resp = await fetch('/template_mau.xlsx');
                const buffer = await resp.arrayBuffer();

                // Direct XML parsing to see EVERY row
                section('1. Raw Template XML — ALL Rows of Sheet 1');
                const zip = await JSZip.loadAsync(buffer);

                // Get sheet paths
                const relsXml = await zip.file('xl/_rels/workbook.xml.rels').async('string');
                log(`Rels XML length: ${relsXml.length}`);

                // Parse shared strings
                const ssXml = await zip.file('xl/sharedStrings.xml').async('string');
                const ssDoc = new DOMParser().parseFromString(ssXml, 'application/xml');
                const siNodes = ssDoc.getElementsByTagName('si');
                const strings = [];
                for (let i = 0; i < siNodes.length; i++) {
                    const tNodes = siNodes[i].getElementsByTagName('t');
                    let text = '';
                    for (let j = 0; j < tNodes.length; j++) text += tNodes[j].textContent || '';
                    strings.push(text);
                }
                log(`Shared strings: ${strings.length}`);

                // Find all sheet files
                const sheetFiles = [];
                zip.forEach((path, entry) => {
                    if (path.match(/xl\/worksheets\/sheet\d+\.xml/)) {
                        sheetFiles.push(path);
                    }
                });
                sheetFiles.sort();
                log(`Sheet files found: ${sheetFiles.join(', ')}`);

                // Parse FIRST sheet — dump every row
                const sheetXml = await zip.file(sheetFiles[0]).async('string');
                const doc = new DOMParser().parseFromString(sheetXml, 'application/xml');
                const allRows = doc.getElementsByTagName('row');

                log(`\nTotal rows in sheet1: ${allRows.length}`);
                log('');

                for (let i = 0; i < allRows.length; i++) {
                    const row = allRows[i];
                    const rn = parseInt(row.getAttribute('r'));
                    const cells = row.getElementsByTagName('c');

                    const cellDescs = [];
                    let hasFormula = false;
                    let hasSubtotal = false;

                    for (let j = 0; j < cells.length; j++) {
                        const c = cells[j];
                        const ref = c.getAttribute('r');
                        const t = c.getAttribute('t') || '';
                        const v = c.getElementsByTagName('v')[0];
                        const f = c.getElementsByTagName('f')[0];

                        let desc = ref;
                        let displayText = '';
                        if (t === 's' && v) {
                            const idx = parseInt(v.textContent);
                            displayText = strings[idx] || '??';
                            desc += `="${displayText}"`;
                        } else if (v) {
                            desc += `=${v.textContent}`;
                            displayText = v.textContent;
                        }
                        if (f) {
                            desc += ` F:(${f.textContent})`;
                            hasFormula = true;
                        }

                        if (displayText.includes('小計') || displayText.includes('合計') ||
                            displayText.includes('税金') || displayText.includes('備考')) {
                            hasSubtotal = true;
                        }

                        cellDescs.push(desc);
                    }

                    let zone = '';
                    let cls = 'info';
                    if (rn <= 14) { zone = '[HEADER]'; cls = 'header'; }
                    else if (rn === 15) { zone = '[COL-HDR]'; cls = 'header'; }
                    else if (rn >= 16 && rn <= 53) { zone = '[DATA]'; cls = 'data'; }
                    else { zone = '[FOOTER]'; cls = 'footer'; }

                    if (hasSubtotal) cls = 'important';
                    if (hasFormula) cls = 'warn';

                    log(`Row ${rn} ${zone}: ${cellDescs.join(' | ')}`, cls);
                }

                // Now check: what does the analysis think?
                section('2. Template Engine Analysis');
                const templateData = await TemplateEngine.analyzeTemplate(buffer);
                const analysis = templateData.analysis;

                log(`Data zone: rows ${analysis.dataZone.startRowNum} - ${analysis.dataZone.endRowNum}`);
                log(`Footer zone startIdx: ${analysis.footerZone.startIdx}`);
                log(`Footer rows: ${analysis.footerZone.rows.length}`);
                log(`Category rows: ${analysis.dataZone.categoryRows?.length || 0}`);

                if (analysis.dataZone.categoryRows?.length > 0) {
                    log('\nCategory rows within data zone:');
                    for (const cr of analysis.dataZone.categoryRows) {
                        log(`  Index ${cr.index}: Row ${cr.row.rowNum} — ${cr.row.cells.map(c => c.displayValue).join(' | ')}`, 'important');
                    }
                }

                log('\nFooter row details:');
                for (const fr of analysis.footerZone.rows) {
                    const cellInfo = fr.cells.map(c => {
                        let desc = `${c.ref}=[${c.displayValue || ''}]`;
                        if (c.formula) desc += ` F:(${c.formula})`;
                        return desc;
                    }).join(', ');
                    log(`  Row ${fr.rowNum}: ${cellInfo}`, fr.cells.some(c => c.formula) ? 'warn' : 'footer');
                }

                // Now generate with 28 rows and dump the OUTPUT
                section('3. Generated Output — 28 rows');
                const testData = [];
                for (let i = 0; i < 28; i++) {
                    testData.push([
                        i + 4, `Measure ${String.fromCharCode(65 + (i % 26))}`,
                        `(1x60 mL+1x20 mL)`, 130000 + i * 10000, 50, 50, 6500000 + i * 100000
                    ]);
                }

                const blob = await TemplateEngine.generateFromTemplate(templateData, {
                    rows: testData,
                    sheetName: 'TestOutput',
                });

                const outZip = await JSZip.loadAsync(await blob.arrayBuffer());
                const outSheetXml = await outZip.file(templateData.firstSheetPath).async('string');
                const outDoc = new DOMParser().parseFromString(outSheetXml, 'application/xml');
                const outRows = outDoc.getElementsByTagName('row');

                // New shared strings
                const outSsXml = await outZip.file('xl/sharedStrings.xml').async('string');
                const outSsDoc = new DOMParser().parseFromString(outSsXml, 'application/xml');
                const outSiNodes = outSsDoc.getElementsByTagName('si');
                const outStrings = [];
                for (let i = 0; i < outSiNodes.length; i++) {
                    const tNodes = outSiNodes[i].getElementsByTagName('t');
                    let text = '';
                    for (let j = 0; j < tNodes.length; j++) text += tNodes[j].textContent || '';
                    outStrings.push(text);
                }

                const expectedDataEnd = 16 + 28 - 1; // = 43
                log(`Expected data end: row ${expectedDataEnd}`);
                log(`Total output rows: ${outRows.length}`);
                log('');

                // Show all rows from near end of data
                for (let i = 0; i < outRows.length; i++) {
                    const row = outRows[i];
                    const rn = parseInt(row.getAttribute('r'));
                    if (rn < expectedDataEnd - 2) continue; // Show from near end

                    const cells = row.getElementsByTagName('c');
                    const cellDescs = [];
                    let hasSubtotal = false;

                    for (let j = 0; j < cells.length; j++) {
                        const c = cells[j];
                        const ref = c.getAttribute('r');
                        const t = c.getAttribute('t') || '';
                        const v = c.getElementsByTagName('v')[0];
                        const f = c.getElementsByTagName('f')[0];

                        let desc = ref;
                        let displayText = '';
                        if (t === 's' && v) {
                            const idx = parseInt(v.textContent);
                            displayText = outStrings[idx] || '??';
                            desc += `="${displayText}"`;
                        } else if (v) {
                            desc += `=${v.textContent}`;
                        }
                        if (f) desc += ` F:(${f.textContent})`;
                        if (displayText.includes('小計') || displayText.includes('合計') ||
                            displayText.includes('税金') || displayText.includes('備考')) {
                            hasSubtotal = true;
                        }
                        cellDescs.push(desc);
                    }

                    log(`Row ${rn}: ${cellDescs.join(' | ')}`, hasSubtotal ? 'important' : 'info');
                }

                // Check OTHER sheets in output
                section('4. Other Sheets in Output');
                const outSheetFiles = [];
                outZip.forEach((path, entry) => {
                    if (path.match(/xl\/worksheets\/sheet\d+\.xml/)) {
                        outSheetFiles.push(path);
                    }
                });
                outSheetFiles.sort();
                log(`Sheet files in output: ${outSheetFiles.join(', ')}`);

                for (const sf of outSheetFiles) {
                    if (sf === templateData.firstSheetPath) continue; // Skip first sheet (already analyzed)
                    const shXml = await outZip.file(sf).async('string');
                    const shDoc = new DOMParser().parseFromString(shXml, 'application/xml');
                    const shRows = shDoc.getElementsByTagName('row');
                    let rowCount = shRows.length;

                    // Check for 小計 content
                    let hasSubtotal = false;
                    for (let i = 0; i < shRows.length; i++) {
                        const cells = shRows[i].getElementsByTagName('c');
                        for (let j = 0; j < cells.length; j++) {
                            const t = cells[j].getAttribute('t') || '';
                            const v = cells[j].getElementsByTagName('v')[0];
                            if (t === 's' && v) {
                                const idx = parseInt(v.textContent);
                                if (outStrings[idx]?.includes('小計') ||
                                    outStrings[idx]?.includes('備考')) {
                                    hasSubtotal = true;
                                }
                            }
                        }
                    }

                    log(`${sf}: ${rowCount} rows, has小計/備考: ${hasSubtotal}`, hasSubtotal ? 'important' : 'info');
                }

                log('\nDone!', 'pass');
            } catch (err) {
                log('ERROR: ' + err.message, 'fail');
                log(err.stack, 'fail');
            }
        });
    </script>
</body>

</html>